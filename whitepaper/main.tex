\documentclass[11pt,a4paper]{article}

% =====================================================
% PACKAGES
% =====================================================

% Page layout
\usepackage[margin=1in]{geometry}
\usepackage{setspace}

% Typography
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{microtype}

% Math and algorithms
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{mathtools}
\usepackage{algorithm}
\usepackage{algpseudocode}

% Graphics and figures
\usepackage{graphicx}
\usepackage{float}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{tikz}
\usepackage{pgfplots}
\pgfplotsset{compat=1.18}

% Tables
\usepackage{booktabs}
\usepackage{multirow}
\usepackage{array}

% References and citations
\usepackage[hidelinks]{hyperref}
\usepackage[capitalize,noabbrev]{cleveref}
\usepackage[backend=biber,style=numeric,sorting=none]{biblatex}
\addbibresource{references.bib}

% Code listings (useful for smart contracts)
\usepackage{listings}
\usepackage{xcolor}

% Define colors for code
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

% Code listing style
\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2
}
\lstset{style=mystyle}

% Other useful packages
\usepackage{enumitem}
\usepackage{csquotes}

% =====================================================
% THEOREM ENVIRONMENTS
% =====================================================
\theoremstyle{definition}
\newtheorem{definition}{Definition}[section]
\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}{Lemma}[section]
\newtheorem{proposition}{Proposition}[section]
\newtheorem{corollary}{Corollary}[theorem]
\newtheorem{example}{Example}[section]
\newtheorem{remark}{Remark}[section]

% =====================================================
% DOCUMENT METADATA
% =====================================================
\title{CBMM Pool: A Constant Burn Market Maker}
\author{@mmatdev \\
        Access Protocol\\
        \texttt{vladislav@accessprotocol.co}}
\date{\today}

% =====================================================
% DOCUMENT
% =====================================================
\begin{document}

\maketitle

\begin{abstract}
This whitepaper describes the CBMM (Constant Burn Market Maker) pool, an improved version of the standard constant product market maker (CPMM) that automates token burns and buybacks resulting in a positive impact on the token's price and more continuous demand.
\end{abstract}

\section{Introduction}

Constant function market makers (CFMMs) have become a foundational primitive for decentralized exchanges~\cite{AngerisChitra2020CFMMOracles}. Variants include constant product market makers (CPMMs) such as Uniswap~v1~\cite{Uniswap-v1-whitepaper}, concentrated liquidity market makers (CLMMs) like Uniswap~{}v3~\cite{UniswapV3Whitepaper2021}, and dynamic automated market makers (DAMMs)~\cite{MeteoraDAMMv2Docs}. Bonding curves~\cite{Bancor2018Whitepaper}, popularized by platforms like Pump.fun, represent another approach where token price is determined by a deterministic curve based on supply.

Existing mechanisms provide no built-in way to translate off-chain activity into on-chain price impact. The only mechanism available to drive positive price action is manual buy-and-burn operations, where participants purchase tokens and burn them to reduce supply. This requires coordination, creates friction, and does not automatically link rewards to verifiable off-chain behavior.

We present the Constant Burn Market Maker (CBMM), a mechanism that enables tying off-chain events to underlying asset supply reduction. CBMM utilizes a virtual token reserve that supports controlled burns without violating pool invariant constraints and enables creating one-sided launch pools. These burns directly increase price proportionally to the amount of beans held outside the pool. Moreover, to compensate for the virtual reserve reduction that accompanies burns, we implement Continuous Conditional Buybacks (CCB), which route a portion of trading fees into the real token reserve, effectively increasing collateralization and increasing price further.

The remainder of this paper is structured as follows. Section~\ref{sec:math} develops the mathematical model, derives trading and burning formulas, and analyzes price impact. Section~\ref{sec:implementation} describes the Solana program implementation, including safety mechanisms and configuration considerations.

\section{Mathematical Model}
\label{sec:math}

In this section we will define the mathematical model of the CBMM pool. We only focus on the token trading and burning mechanics and additional buyback mechanics.

We first define the key terms used throughout this section. Let there be a CPMM pool with a token reserve $R$ and a beans reserve $B$. The token reserve is split into \textbf{Real Token Reserve} $A$ (backed by actual assets) and a \textbf{Virtual Token Reserve} $V$ (not backed by assets, used to set the initial price and liquidity). The pool trading mechanics are defined by the constant product invariant $k = (A+V)B$. We say that this pool is a \textbf{CBMM pool} if it implements the beans burn functionality tied to the virtual reserve reduction as described later in this section.

The CPMM pool is said to be \textbf{insolvent} if its reserves are insufficient to accommodate the sale of all outstanding beans; otherwise it is said to be \textbf{solvent}. We design the CBMM pool to be solvent by adjusting the virtual reserve after each burn.

We assume the initial Real Token Reserve is zero. CBMM is designed as a token rollout mechanism, so we do not need to account for any existing supply outside the pool. The Virtual Token Reserve sets the initial price of the token.

\subsection{Trading}

Buys and sells in CBMM follow the mechanics of the standard CPMM with a virtual reserve; we include them here for completeness. The pre-trade (buy or sell) values are
\begin{align*}
    A &= A_0, &
    B &= B_0, &
    V &= V, &
    k &= (A_0 + V) B_0.
\end{align*}

During trading, the invariant $k$ and the virtual reserve $V$ do not change. The amount of beans $b$ received by the user when spending $\Delta A$ tokens (which increases the pool reserve to $A_0+\Delta A$) follows from
\begin{equation}
    k = (A_0+\Delta A+V)(B_0-b),
\end{equation}
which gives:

\begin{equation}
    b = B_0 - \frac{k}{A_0+\Delta A+V}.
\end{equation}

Similarly, the amount of tokens $a$ received by the user when spending $\Delta B$ beans (which increases the pool reserve to $B+\Delta B$) follows from
\begin{equation}
    k = (A_0-a+V)(B_0+\Delta B),
\end{equation}
which gives:

\begin{equation}
    a = A_0+V - \frac{k}{B_0+\Delta B}.
\end{equation}

The price of beans $P$ (tokens per bean) is derived from the marginal rate of exchange. Starting with the invariant $k = (A+V)B$ and holding $k$ constant, we differentiate with respect to $B$:

\begin{equation}
    \frac{d}{dB}[(A+V)B] = \frac{dA}{dB} \cdot B + (A+V) = 0,
\end{equation}

which yields $\frac{dA}{dB} = -(A+V)/B$. The price is the negative of this derivative:

\begin{equation}
    P = -\frac{dA}{dB} = \frac{A+V}{B}.
\end{equation}

\subsection{Beans Reserve Burning}
\label{sec:beans-reserve-burning}

This section describes the necessary conditions for the CBMM pool to remain solvent after a beans reserve reduction.

Let the initial state of the pool be

\begin{align*}
    A_0 &= 0, &
    B_0 &= B, &
    V_0 &= V, &
    k_0 &= (0 + V) B = V B.
\end{align*}

Assume, without loss of generality, that trading occurs before the burn, lowering the beans reserve by $x \geq 0$. The post-trade values are
\begin{align*}
    A_1 &= \frac{Vx}{B - x}, &
    B_1 &= B - x, &
    V_1 &= V, &
    k_1 &= k_0 = V B.
\end{align*}

Now, if we burn $y$ beans with $0 \leq y < B - x$, the post-burn state is
\begin{align*}
    A_2 &= \frac{Vx}{B - x}, &
    B_2 &= B - x - y, &
    V_2 &\text{ to be determined}, &
    k_2 &= (A_2 + V_2) B_2.
\end{align*}

Finally, to ensure the pool is solvent, if everyone sells their beans back to the pool, there must be sufficient tokens to satisfy the sale. The post-sale state must satisfy
\begin{align*}
    A_3 &\geq 0, &
    B_3 &= B - y, &
    V_3 &= V_2, &
    k_3 &= (A_3 + V_3) B_3.
\end{align*}

From $k_2 = k_3$ and $k_3 \geq V_3 B_3$, we obtain a bound on $V_2$ that ensures the pool is solvent:

\begin{equation}
    V_2 \leq \frac{V(B-x-y)}{B-x}.
\end{equation}

Thus, after every burn, the virtual reserve must be adjusted downward to ensure solvency. A natural choice is to set $V_2$ to the maximum value satisfying the bound, which minimizes the price impact of the virtual reserve reduction.

\textbf{TODO: CHECK THIS}
Note that maintaining solvency via this adjustment can imply that the worst-case exit price for sellers after burns is lower than the initial anchor price set by the starting $V$. The worst-case exit price refers to the marginal price when all outstanding beans (post-burn) are sold back to the pool, driving the real token reserve $A$ toward zero. At this limit, the price approaches $V_2/(B-y)$, which may be below the initial price $V/B$ if $V_2 < V(B-y)/B$.

\subsubsection{Price impact of the burn}

Denote the price before burn as $P_1 = \frac{A_1+V_1}{B_1}$ and the price after burn as $P_2 = \frac{A_2+V_2}{B_2}$. Substituting the values from the previous section, where $B_1 = B - x$ and $V_2 = \frac{V(B - x - y)}{B - x}$, we obtain
\begin{align*}
    P_1 &= \frac{A_1 + V_1}{B_1} = \frac{\frac{Vx}{B-x} + V}{B-x} = \frac{VB}{(B-x)^2}, \\
    P_2 &= \frac{A_2 + V_2}{B_2} = \frac{\frac{Vx}{B-x} + \frac{V(B-x-y)}{B-x}}{B-x-y} = \frac{V(B-y)}{(B-x)(B-x-y)}.
\end{align*}

The relative price impact of the burn is then:

\begin{equation}
    \frac{P_2 - P_1}{P_1} = \frac{xy}{B(B-x-y)}.
\end{equation}

This formula shows that the relative price impact is proportional to the product $xy$ of beans held outside the pool $x$ and beans burned $y$, divided by $B(B-x-y)$. The impact increases with $x$, meaning burns have greater price impact when more tokens have been purchased. If $x = 0$ (no tokens purchased), the burn has no price impact, as expected.

Operationally, burns reduce the beans reserve $B$, tightening depth and available liquidity at the new state.

\subsection{Token Reserve Top-up}

Burns reduce the beans reserve $B$ and force a downward adjustment of the virtual reserve $V$. This causes a liquidity reduction and price raise offset by the price curve getting steeper and the initial price being reduced. This unwanted side effect can be undone by adding tokens to the real token reserve $A$ which we call top-up. This subsection derives the exact top-up amount needed to restore the token starting price without changing the logic introduced earlier.

Let $T$ denote the total bean supply (equal to the in-pool beans because we start with zero circulating supply). The pre-trade state is
\begin{align*}
    A_0 &= 0, &
    B_0 &= B, &
    V_0 &= V, &
    T_0 &= B_0, &
    k_0 &= (A_0+V_0)B_0 = V_0 B_0.
\end{align*}

After trades that extract $x$ beans from the pool, the state is
\begin{align*}
    A_1 &= \frac{Vx}{B-x}, &
    B_1 &= B - x, &
    V_1 &= V, &
    T_1 &= T_0, &
    k_1 &= k_0.
\end{align*}

Next, burn $y$ beans ($0 \le y < B_1$). Let $V_2$ denote the virtual reserve enforced by the solvency condition in \cref{sec:beans-reserve-burning}. The post-burn state is
\begin{align*}
    A_2 &= A_1, &
    B_2 &= B_1 - y, &
    V_2 &\le V_1, &
    T_2 &= T_1 - y, &
    k_2 &= (A_2 + V_2) B_2.
\end{align*}

Our target is to choose a (possibly higher) virtual reserve $V_{\mathrm{opt}}$ and a real token top-up amount $M$ that keep the worst-case exit price -- the price when all outstanding beans are sold back -- at the original value $P_0 = V_0/T_0$. When everyone exits after the burn, the pool holds $B_3 = T_2$ beans and zero real tokens, so the price limit becomes $P_3 = V_{\mathrm{opt}}/T_2$. Enforcing $P_3 = P_0$ yields
\begin{align}
    \frac{V_0}{T_0} = \frac{V_{\mathrm{opt}}}{T_2}
    \quad \Longrightarrow \quad
    V_{\mathrm{opt}} = \frac{T_2}{T_0} V_0 = \frac{B_0-y}{B_0} V_0.
\end{align}

With $V_{\mathrm{opt}}$ fixed, the invariant that corresponds to the desired price profile is
\begin{equation}
    k_{\mathrm{opt}} = (0 + V_{\mathrm{opt}}) T_2 = V_{\mathrm{opt}} T_2.
\end{equation}
The pool at beans reserve $B_2$ after the burn implies a target real token reserve
\begin{equation}
    A_{\mathrm{opt}} = \frac{k_{\mathrm{opt}}}{B_2} - V_{\mathrm{opt}}.
\end{equation}
The actual reserve after the burn equals $A_2 = Vx/(B-x)$, so the required token top-up is simply
\begin{equation}
    M = A_{\mathrm{opt}} - A_2.
\end{equation}

\subsubsection{Trading impact on required top-up amount}
\label{sec:trading-impact-on-required-top-up-amount}

After the top-up, subsequent trades shift the beans reserve from $B_2$ to $B' = B_2 + \Delta B$. Feasibility requires $-B_2 < \Delta B \le T_2 - B_2$: buyers cannot withdraw more beans than the pool holds, and sellers cannot dump more than the outstanding supply. Positive $\Delta B$ therefore corresponds to net sells back into the pool, while negative $\Delta B$ captures net buys. The optimal real reserve that preserves the target price profile remains tied to $k_{\mathrm{opt}}$:
\begin{align}
    A_{\mathrm{opt}}' = \frac{k_{\mathrm{opt}}}{B'} - V_{\mathrm{opt}}.
\end{align}
Meanwhile, the actual reserve induced by the current invariant $k = (A_2 + V_2)B_2$ becomes
\begin{align}
    A_{\mathrm{real}}' = \frac{k}{B'} - V_2.
\end{align}
The updated top-up requirement is therefore
\begin{align}
    M' = A_{\mathrm{opt}}' - A_{\mathrm{real}}' = \frac{k_{\mathrm{opt}} - k}{B'} + (V_2 - V_{\mathrm{opt}}).
\end{align}
Buys ($\Delta B < 0$) shrink $B'$, amplifying the first term and increasing $M'$; sells ($\Delta B > 0$) expand $B'$ and dampen the same term, but the additive offset $(V_2 - V_{\mathrm{opt}}) < 0$ keeps the gap positive. At the boundary case $\Delta B = T_2-B_2$ the expression is undefined. In that state no beans are left outside the pool so the pool price can be reset to the original initial price by setting $V = V_{\mathrm{opt}}$ without any top-up.

\subsubsection{Partial Top-ups}

Suppose only $M' < M$ tokens are available for the top-up immediately after the burn. Injecting $M'$ raises the real reserve to $A_{\mathrm{new}} = A_2 + M'$ while the beans reserve stays at $B_2$. The invariant is therefore
\begin{equation}
    k_{\mathrm{new}} = (A_{\mathrm{new}} + V_{\mathrm{new}}) B_2.
\end{equation}
We do not target a specific $k_{\mathrm{new}}$; instead we push the post-injection price as high as pool solvency requirement allows. When every outstanding bean ($T_2 - B_2$ in total) is sold back, the goal is for the pool to reach $A = 0$. At that point the invariant becomes
\begin{equation}
    k_{\mathrm{new}} = V_{\mathrm{new}} T_2.
\end{equation}
Equating both expressions for $k_{\mathrm{new}}$ yields the virtual reserve closest to $V_{\mathrm{opt}}$ under a partial top-up that keeps the pool solvent:
\begin{align*}
    &A_{\mathrm{new}} = A_2 + M', \\
    &V_{\mathrm{new}} = \frac{A_{\mathrm{new}} B_2}{T_2 - B_2}.
\end{align*}
When $T_2 > B_2$, this choice keeps the pool solvent and maximizes the achievable price lift given the available collateral. Any subsequent injection simply repeats the calculation with updated $A_{\mathrm{new}}$ and moves $V_{\mathrm{new}}$ closer to $V_{\mathrm{opt}}$ until the full top-up is completed.

As already discussed in \cref{sec:trading-impact-on-required-top-up-amount}, if trades drive $T_2 = B_2$ (no beans outside the pool), $V$ can be reset directly to $V_{\mathrm{opt}}$ because no outstanding holders remain.

\subsection{Other invariant types}

\begin{definition}[Power CBMM]
\textbf{Power CBMM} generalizes the standard CBMM by using a power parameter $p > 0$ in the invariant:
\begin{equation}
    k = (A+V)B^p,
\end{equation}
where $A$ is the token reserve, $B$ the beans reserve, $V$ the virtual reserve, and $p$ is a real parameter controlling the curve's shape.
\end{definition}

When $p = 1$, this reduces to the standard CBMM invariant. The parameter $p$ controls the curvature of the bonding curve: $p > 1$ produces a steeper curve, while $0 < p < 1$ produces a flatter curve. This allows fine-tuning of the pool's behavior, particularly affecting initial token purchases and the distribution of tokens to early adopters~\cite{BalancerWhitepaper2020}.

The trading formulas for Power CBMM follow from the invariant $k = (A+V)B^p$. When spending $\Delta A$ tokens to buy beans, the amount of beans $b$ received is:

\begin{equation}
    b = B - \left(\frac{(A+V)B^p}{A+\Delta A+V}\right)^{1/p}.
\end{equation}

When selling $\Delta B$ beans into the pool, the amount of tokens $a$ received is:

\begin{equation}
    a = (A+V)\left(1 - \frac{B^p}{(B+\Delta B)^p}\right).
\end{equation}

After burning $y$ beans when $x$ beans have already been purchased, the virtual reserve must be adjusted to maintain solvency. The adjusted virtual reserve $V_2$ can be derived in a similar way as in the standard CBMM case as:

\begin{equation}
    V_2 = \frac{V \left((B-x)^p - B^p\right) (B-x-y)^p}{(B-x)^p \left((B-x-y)^p - (B-y)^p\right)},
\end{equation}

For $x=0$, the bound gives $V_2=V$ (no adjustment). For $x>0$ and $0 \leq y < B-x$, the expression is well-defined and yields $V_2<V$.

The price formula for Power CBMM is:

\begin{equation}
    P = \frac{p(A+V)}{B}.
\end{equation}

When $p = 1$, this reduces to the standard CBMM price formula $P = (A+V)/B$.

We have considered other invariant types such as weighted geometric mean but it shows that the virtual reserve formulas are too complex to be conveniently implemented in the on-chain program using integer arithmetic.

\subsection{Value Extraction Considerations and Mitigation Strategies}

Burns shrink the beans reserve, force a reduction of the virtual reserve, and steepen the price curve. When the top-up prescribed in \cref{sec:token-reserve-top-up} is only partially executed, successive burns can move the anchor price materially lower than the value implied by the original $V$. This section quantifies the exact profit that an adversary can realize via a buy--burn--sell loop and outlines mitigation levers.

\subsubsection{Attack model and payoff derivation}

Consider a pool in state $(A,B,V)$ with invariant $k = (A+V)B$ and some beans in circulation. Total beans supply is $T \geq B$. An adversary executes the following steps:
\begin{enumerate}[leftmargin=*]
    \item \textbf{Buy $x$ beans.} Spending $\Delta A_{\mathrm{in}}$ tokens yields $x$ beans according to the standard CPMM expression
    \begin{equation}
        \Delta A_{\mathrm{in}} = (A+V)\frac{x}{B-x}, \qquad 0 < x < B.
        \label{eq:value-extraction-buy}
    \end{equation}
    The post-buy reserves are $A_1 = A + \Delta A_{\mathrm{in}}$ and $B_1 = B - x$.
    \item \textbf{Trigger a burn of $y$ beans} from the pool (with $0 < y < B-x$), enforcing solvency by reducing the virtual reserve to
    \begin{equation}
        V_2 = \frac{V(B - x - y)}{B - x},
        \label{eq:value-extraction-V2}
    \end{equation}
    so that the new invariant remains $k_2 = (A_1 + V_2)(B - x - y)$.
    \item \textbf{Sell the $x$ beans back.} Using the sell formula from \cref{sec:math}, the attacker receives
    \begin{equation}
        A_{\mathrm{out}} = \frac{(A_1 + V_2)x}{B - y}
        \label{eq:value-extraction-sell}
    \end{equation}
    tokens while the pool returns to beans reserve $B - y$.
\end{enumerate}

Combining \cref{eq:value-extraction-buy,eq:value-extraction-V2,eq:value-extraction-sell} yields a closed-form expression for the net token profit:
\begin{equation}
    \Pi(x,y) = A_{\mathrm{out}} - \Delta A_{\mathrm{in}}
             = \frac{Axy}{(B - x)(B - y)}.
    \label{eq:value-extraction-profit}
\end{equation}

Key implications: \textbf{TODO: CHECK THIS}
\begin{itemize}[leftmargin=*]
    \item No real reserve means no extractable value: $\Pi=0$ whenever $A=0$.
    \item Profit grows jointly with $x$ and $y$, peaking as both approach $B$. In the limit $\lim_{x,y\rightarrow B}\Pi(x,y)=A$, so one adversary holding nearly all beans can strip the entire real reserve.
    \item The attack strictly consumes the existing real collateral. After the sell, the pool ends up with $A-\Pi$ tokens, so repeated loops cannot extract more than what has already been topped up.
\end{itemize}

Therefore, any mechanism that increases $A$ (top-ups, fee sweeps, external injections) must ensure that burns cannot be immediately chained by a single party holding the majority of outstanding beans.

\subsubsection{Attack model with symmetric base-token fees}

To actively suppress the buy--burn--sell loop, we impose an $N\%$ fee on every trade, collected entirely in the base token. This fee penalizes extraction attempts in the following way. Define the fee multiplier
\begin{equation}
    q = \frac{100}{100 - N}
\end{equation}
All fees are skimmed from the trader's base-token transfers: buy-side fees are removed before tokens enter the pool, and sell-side fees are shaved off before proceeds hit the attacker's wallet.

\paragraph{Step 1: buy $x$ beans.}
To withdraw $x$ beans ($0 < x < B$), the trader must send $S_{\text{buy}}$ tokens so that the post-fee deposit equals the CBMM requirement. Solving
\begin{equation}
    (A+V)B = \bigl(A + S_{\text{buy}}/q + V\bigr)(B - x)
\end{equation}
gives
\begin{equation}
    S_{\text{buy}} = q\,\frac{(A+V)x}{B - x}.
\end{equation}
The pool itself still sees $A_1 = A + \frac{(A+V)x}{B-x}$ and $B_1 = B - x$, identical to the no-fee path, while the attacker cost is increased by the fees.

\paragraph{Step 2: burn $y$ beans.}
Burning $y$ beans ($0 < y < B_1$) forces the same solvency adjustment as before:
\begin{align*}
    A_2 &= A_1, &
    B_2 &= B - x - y, &
    V_2 &= \frac{V(B - x - y)}{B - x}.
\end{align*}

\paragraph{Step 3: sell the $x$ beans back.}
When the attacker sells the $x$ beans, the on-chain invariant after the burn is
\begin{equation}
    k_{\text{burn}} = (A_2 + V_2)B_2.
\end{equation}
Trading $x$ beans back into the pool yields the pre-fee token outflow $S_{\text{pool}}$ defined by
\begin{equation}
    (A_2 + V_2)B_2 = \bigl(A_2 - S_{\text{pool}} + V_2\bigr)(B_2 + x),
\end{equation}
which solves to
\begin{equation}
    S_{\text{pool}} = \frac{x}{(B - x)(B - y)}\Bigl[B(A+V) - Vy\Bigr].
\end{equation}
The fee clips a factor $1/q$ from the output, so the attacker actually receives
\begin{equation}
    S_{\text{sell}} = \frac{1}{q}\,S_{\text{pool}}
    = \frac{1}{q}\,\frac{x}{(B - x)(B - y)}\Bigl[B(A+V) - Vy\Bigr].
\end{equation}

\paragraph{Net payoff and burn threshold.}
The round-trip profit becomes
\begin{equation}
    \Pi_{\text{fee}}(x,y)
        = S_{\text{sell}} - S_{\text{buy}}
        = \frac{x}{q(B - x)(B - y)}
            \left[q^2(A+V)(B - y) - B(A+V) + Vy\right].
\end{equation}
Fees suppress the attack whenever the bracketed term is non-negative. Solving the linear inequality for $y$ yields the maximum burn size that still keeps the attacker under water:
\begin{equation}
    y \le y_{\max}
        = \frac{(q^2 - 1)B(A+V)}{q^2(A+V) - V},
\end{equation}
Assuming $A>0$ (otherwise there is nothing to extract) keeps the denominator positive. The bound scales linearly with the beans reserve $B$; the multiplier depends on the fee rate (via $q$), the virtual reserve $V$, and the real reserve $A$. Setting $N = 0$ (so $q = 1$) collapses the bound to $y_{\max} = 0$, matching the logic in \cref{eq:value-extraction-profit}. For $q>1$, the attack is eliminated whenever the configured burn allowance lies below $y_{\max}$.

Notably, the profitability condition depends only on the burn size $y$ relative to the pool parameters; the buy size $x$ affects the magnitude of profit but not its sign, so the threshold $y_{\max}$ is independent of the attacker's purchase amount.

\subsubsection{Attack model with symmetric base-token fees and topup}

We extend the attack model to account for a token reserve top-up $N$ that occurs after the burn. The top-up increases the real token reserve from $A_1$ to $A_2 = A_1 + N$, requiring adjustment of the virtual reserve $V_2$ to maintain solvency.

Following the same attack steps as before, but with top-up applied: the attacker buys $x$ beans, spending $S_{\text{buy}} = q(A+V)x/(B-x)$ tokens. After burning $y$ beans and applying top-up $N$, the reserves become $A_2 = A + (A+V)x/(B-x) + N$ and $B_2 = B - x - y$. The virtual reserve adjusts according to the partial top-up formula from \cref{sec:token-reserve-top-up} to maintain solvency:
\begin{equation}
    V_2 = \frac{A_2 B_2}{T_2 - B_2} = \frac{A_2 (B - x - y)}{(T - y) - (B - x - y)} = \frac{A_2 (B - x - y)}{T - B + x}.
    \label{eq:V2-with-topup}
\end{equation} 

When the attacker sells $x$ beans back, the pool must maintain the invariant $(A_2 + V_2) \cdot B_2 = (A_2 - S_{\text{pool}} + V_2) \cdot (B_2 + x)$, where $S_{\text{pool}}$ is the pre-fee token outflow. Solving for $S_{\text{pool}}$ and substituting $V_2 = A_2 B_2 / (T - B + x)$ and $B_2 + x = B - y$:
\begin{equation}
    S_{\text{pool}} = \frac{A_2 \cdot x \cdot (T - y)}{(B - y)(T - B + x)},
\end{equation}
where $A_2 = A + (A+V)x/(B-x) + N$. After applying the fee, the attacker receives:
\begin{equation}
    S_{\text{sell}} = \frac{1}{q} \cdot S_{\text{pool}} = \frac{x (T - y)}{q(B - y)(T - B + x)}\left(A + N + \frac{(A+V)x}{B-x}\right).
\end{equation}
The round-trip profit is the difference between what the attacker receives and what they spend:
\begin{equation}
    \Pi_{\text{topup}}(x,y,N) = S_{\text{sell}} - S_{\text{buy}}.
\end{equation}
Substituting the expressions for $S_{\text{sell}}$ and $S_{\text{buy}} = q \cdot \frac{(A+V)x}{B-x}$:
\begin{equation}
    \Pi_{\text{topup}}(x,y,N) = \frac{x (T - y)}{q(B - y)(T - B + x)}\left(A + N + \frac{(A+V)x}{B-x}\right) - q\,\frac{(A+V)x}{B-x}.
    \label{eq:topup-profit}
\end{equation}


Since the profit $\Pi_{\text{topup}}$ is increasing in $N$, the worst case for the defender occurs when $N = M$. Substituting $N = M$ into \cref{eq:topup-profit} and using the expression for $M$ from \cref{sec:token-reserve-top-up}:

\begin{align}
    M &= A_{\mathrm{opt}} - A_2 \nonumber \\
    &= \frac{k_{\mathrm{opt}}}{B_2} - V_{\mathrm{opt}} - A_2 \nonumber \\
    &= \frac{V_{\mathrm{opt}} T_2}{B_2} - V_{\mathrm{opt}} - A_2 \nonumber \\
    &= V_{\mathrm{opt}}\left(\frac{T_2}{B_2} - 1\right) - A_2 \nonumber \\
    &= \frac{T-y}{T} V \cdot \frac{T - y - (B - x - y)}{B - x - y} - A - \frac{(A+V)x}{B-x} \nonumber \\
    &= \frac{T-y}{T} V \cdot \frac{T - B + x}{B - x - y} - A - \frac{(A+V)x}{B-x},
    \label{eq:M-bound}
\end{align}
where we used $V_{\mathrm{opt}} = \frac{T_2}{T_1} V = \frac{T-y}{T} V$, $T_2 = T - y$, $B_2 = B - x - y$, and $A_2 = A + (A+V)x/(B-x)$.

Substituting $N = M$ into \cref{eq:topup-profit} and using $A + M + \frac{(A+V)x}{B-x} = \frac{T-y}{T} V \cdot \frac{T - B + x}{B - x - y}$:
\begin{align}
    \Pi_{\text{topup}}(x,y,M) &= \frac{x (T - y)}{q(B - y)(T - B + x)} \cdot \frac{T-y}{T} V \cdot \frac{T - B + x}{B - x - y} - q\,\frac{(A+V)x}{B-x} \nonumber \\
    &= \frac{x (T - y)^2 V}{q T (B - y)(B - x - y)} - q\,\frac{(A+V)x}{B-x}.
    \label{eq:profit-with-M}
\end{align}

From the invariant $k = (A+V)B$ and the fact that when all beans are in circulation in the pool we have $A = 0$ and $B = T$, we also have $k = VT$. Equating both expressions for $k$ yields
\begin{equation}
    T = \frac{(A+V)B}{V} = \frac{k}{V}.
    \label{eq:T-relationship}
\end{equation}

Substituting the top-up $N = M$ from \cref{eq:M-bound} into \cref{eq:topup-profit} and simplifying gives
\begin{equation}
    \Pi_{\text{topup}}(x,y,M)
    = \frac{x (T - y)^2 V}{q\,T (B - y)(B - x - y)} - q\,\frac{(A+V)x}{B-x}.
    \label{eq:profit-with-M}
\end{equation}

\paragraph{Burn cap and fee condition.}
In practice we cap each burn so that it removes at most a fixed fraction
$\eta$ of the beans remaining in the pool *after* the attacker’s buy:
\begin{equation}
    0 < y \le \eta (B - x), \qquad 0 < \eta < 1.
    \label{eq:burn-cap}
\end{equation}
In the implementation we use $\eta = 0.01$ (a burn of at most $1\%$ of the
current pool). We now derive a sufficient condition on the symmetric fee $N$
such that every buy–burn–topup–sell loop is unprofitable.

Starting from \cref{eq:profit-with-M} and using the burn cap
\cref{eq:burn-cap}, we observe that
\[
    B - x - y \;\ge\; B - x - \eta (B-x)
    \;=\; (1-\eta)(B-x).
\]
Since all denominators are positive, this implies
\[
    \frac{1}{B - x - y}
    \;\le\; \frac{1}{(1-\eta)(B-x)}.
\]
Therefore the first term in \cref{eq:profit-with-M} is upper-bounded by
\[
    \frac{x (T - y)^2 V}{q\,T (B - y)(1-\eta)(B-x)}.
\]
A sufficient condition for $\Pi_{\text{topup}}(x,y,M) \le 0$ is thus
\begin{equation}
    \frac{x (T - y)^2 V}{q\,T (B - y)(1-\eta)(B-x)}
    - q\,\frac{(A+V)x}{B-x} \;\le\; 0.
    \label{eq:topup-bound-1}
\end{equation}

Next we use the trivial bound $(T-y)^2 \le T^2$ (since $0 \le y \le B \le T$),
which only increases the first term. This yields another sufficient condition:
\begin{align}
    \Pi_{\text{topup}}(x,y,M)
    &\le
    \frac{x T^2 V}{q\,T (B - y)(1-\eta)(B-x)}
    - q\,\frac{(A+V)x}{B-x} \nonumber\\
    &= \frac{x T V}{q (B - y)(1-\eta)(B-x)}
       - q\,\frac{(A+V)x}{B-x}.
    \label{eq:topup-bound-2}
\end{align}

Factor out $x/(B-x) > 0$:
\begin{equation}
    \Pi_{\text{topup}}(x,y,M)
    \;\le\; \frac{x}{B-x}
    \left[
        \frac{T V}{q (B - y)(1-\eta)} - q(A+V)
    \right].
\end{equation}
Since $\frac{x}{B-x}>0$, the sign is determined by the bracket.
A sufficient (state-independent) condition for unprofitability is therefore
\begin{equation}
    \frac{T V}{q (B - y)(1-\eta)} - q(A+V) \;\le\; 0.
    \label{eq:bracket-ineq}
\end{equation}

Multiplying \cref{eq:bracket-ineq} by the positive factor
$q(B-y)(1-\eta)$ gives
\begin{equation}
    T V \;\le\; q^2 (A+V)(B-y)(1-\eta).
    \label{eq:TV-ineq}
\end{equation}
Using $T V = (A+V)B$ from \cref{eq:T-relationship}, we obtain
\begin{equation}
    (A+V)B \;\le\; q^2 (A+V)(B-y)(1-\eta)
    \quad\Longrightarrow\quad
    B \;\le\; q^2 (1-\eta)(B-y),
\end{equation}
and hence
\begin{equation}
    \frac{B}{q^2 (1-\eta)} \;\le\; B - y
    \quad\Longrightarrow\quad
    y \;\le\; B\left(1 - \frac{1}{q^2 (1-\eta)}\right).
    \label{eq:y-global-bound}
\end{equation}

Equation \cref{eq:y-global-bound} says that, under the top-up rule,
any burn with
\[
    \frac{y}{B} \;\le\; 1 - \frac{1}{q^2 (1-\eta)}
\]
makes the loop unprofitable. Our burn cap \cref{eq:burn-cap} additionally
enforces $y \le \eta(B-x) \le \eta B$, so it is enough that
\begin{equation}
    \eta \;\le\; 1 - \frac{1}{q^2 (1-\eta)}.
\end{equation}
Solving this inequality gives
\begin{equation}
    q \;\ge\; \frac{1}{1-\eta}.
\end{equation}
Recalling that the symmetric fee $N$ (in percent) and $q$ are related by
$q = \frac{100}{100-N}$, this is equivalent to
\begin{equation}
    N \;\ge\; 100 \eta.
\end{equation}

\paragraph{Parameter choice.}
In our implementation we set $\eta = 0.01$, i.e.\ each burn removes at most
$1\%$ of the current pool after the attacker’s buy. The condition above then
requires only a $1\%$ symmetric base-token fee. We in fact choose a much larger
fee, $N = 5\%$, which corresponds to $q = 100/95 \approx 1.053$ and satisfies
$q \ge 1/(1-\eta)$ with a wide margin.

Therefore, under the burn cap \cref{eq:burn-cap} and a $5\%$ symmetric fee
on the base token, every buy–burn–topup–sell loop has
\[
    \Pi_{\text{topup}}(x,y,M) \le 0
\]
for all admissible $A,B,V,x,y$. The top-up mechanism cannot be profitably
exploited by this class of attacks.

\section{Implementation}
\label{sec:implementation}

This section describes an on-chain implementation of CBMM as a Solana program. The trading principles in CBMM implementation use the same approach as standard CPMM pools and, therefore, are not repeated here. We first present the Continuous Conditional Buybacks mechanism, which partially offsets the required reduction in the virtual reserve $V$ after burns. We then outline safety controls for burn operations and note key configuration considerations. The design objective is to minimize user friction while faithfully realizing the mathematical model from Section~\ref{sec:math}.

\subsection{Continuous Conditional Buybacks}
\label{sec:continuous-conditional-buybacks}

As discussed in \cref{sec:beans-reserve-burning}, burns require a reduction of the virtual reserve from $V_1$ to $V_2$ (with $V_2 < V_1$). This adjustment reduces the positive impact of the burn. We implement the token reserve top-up mechanism described in \cref{sec:token-reserve-top-up} as \textbf{Continuous Conditional Buybacks} (CCB) redirecting a portion of trading fees into the Real Token Reserve $A$.

Let $\Delta V = V_1 - V_2 \ge 0$ denote the required reduction in virtual reserve implied by Section~\ref{sec:math}. The implemented CCB mechanism then works as follows:

\begin{itemize}[leftmargin=*]
  \item \textbf{Fee accumulation}: On each trade, a fixed fraction of token fees is routed to a dedicated on-chain fee vault (an associated token account controlled by the program).
  \item \textbf{Burn-time top-up}: Upon a burn event, the program strives to top-up the pool real and virtual token reserves to the target values $A_{\mathrm{opt}}$ and $V_{\mathrm{opt}}$ as described in \cref{sec:token-reserve-top-up}. Any shortfall is stored in pool state as an outstanding liability $L$.
  \item \textbf{Continuous repayment}: While $L>0$, fees contributed by the subsequent trades are immediately applied to reduce $L$ until it reaches zero. Any overage remains in the fee vault and is handled by the Fee accumulation rule.
\end{itemize}

The Continuous repayment step differs for beans buys and sells. For buys the fees are applied before the operation itself, for sells the fees are applied after the operation. This directly incentivizes buys and penalizes sells. Moreover, the topup always happens with the lower outstanding amount, which lowers the required top-up amount to achieve the target price.

Technically, this is not a buyback, as no beans leave the pool. However, adding tokens to $A$ increases the beans' price and effectively buys back part of the burn's price impact.

If not enough off-chain activity is observed, the trading fees are still accumulated and can be used to top-up the pool in the future. This motivates the off-chain activity to be persistent and ongoing.

\subsection{Burn Safety Mechanisms}

To bound operational risk and align burns with off-chain incentives, we introduce two optional controls: (i) per-user daily burn limits and (ii) a centralized burn authority.

\subsubsection{Daily burn limits}

We introduce a lightweight on-chain counter, \texttt{UserBurnAllowance}, uniquely identified by the user's wallet address. It records the number of burns over a 24-hour window and the timestamp of the most recent burn. Account creation is permissionless (similarly to SPL Associated Token Accounts) so any party can create and fund~\cite{SolanaRent} an account to bootstrap a user's allowance. To avoid rent leakage, accounts associated with users inactive for $\geq 24$ hours may be closed and rent returned to the original funding wallet. If a user exceeds the configured daily limit, additional burn attempts are rejected until the window resets. The impact of each burn is calculated as a hardcoded percentage of the pool's beans reserve. For more significant impact it is possible to burn a percentage of the total supply if the pool reserve is sufficient to do so.

For minimal funding costs and better scalability, equivalent functionality could be realized via State Compression using Concurrent Merkle Trees~\cite{XiaoEtAl2023ConcurrentMerkleTrees}, at the cost of off-chain infrastructure dependence.

\subsubsection{Burn authority}

On every burn we require a signature from a Burn Authority. This ensures that all burns are tied to specific off-chain activities and that users have not simply automated the burn operation by calling the on-chain program directly. This mechanism is optional and can be turned off if decentralization is a priority.

\subsection{Pool Configuration Considerations}

The main decision that influences the pool behavior is the initial virtual reserve $V$. This reserve directly sets the token initial price and is proportional to the trading volume needed to be able to top-up the pool fully. Moreover, the higher initial reserve the more expensive it is to snipe a large amount of beans at the starting price.

To be able to mitigate the sniping issue we can not only use higher virtual reserve, but also use Power CBMM with $p>1$ to increase the price impact of the initial purchases. However, with higher $p$ the on-chain program needs to use more complex arithmetic to implement the trading formulas and ensure that there are no overflows or significant precision loss that would affect the pool's health. From our tests we have found that $p=2$ is a good compromise between complexity and effectiveness.

\section{Conclusion}
\label{sec:conclusion}

This work set out to design a market-making mechanism that can translate verifiable off-chain activity into on-chain price impact through controlled burns. We constructed a mathematical model for CBMM with a virtual reserve $V$ and outlined the closed-form expressions for trading, burning, and the induced price impact. On the implementation side, we described a Solana program architecture that implements these mechanics, introduces Continuous Conditional Buybacks (CCB) to partially offset the virtual-reserve reduction after burns, and adds safety controls to regulate burn frequency and authorization.

The model reveals a clear separation of roles. First, burns directly increase price with a relative impact proportional to the amount of beans outside the pool and the burned amount. The pool trading volume by itself does not directly contribute to the price increase but complements burns by compensating for the virtual reserve deterioration through the Continuous Conditional Buybacks mechanism. Because burning reduces the in-pool supply, it increases price but also increases volatility. The virtual reserve acts here as a bridge mechanism to facilitate a slow transition from a purely virtual scaling system into a progressively collateralized one. In healthy conditions, as $V$ is reduced toward its minimum, the pool matures by price becoming increasingly supported by real collateral rather than virtual scale.

From a design perspective, the initial virtual reserve $V$ sets the starting price and determines how much trading volume is required to fully top up the pool via fees. Larger $V$ makes early sniping more costly. The optional Power CBMM variant controls curve shape via a parameter $p>0$; choosing $p>1$ concentrates price impact at earlier purchases and can be used to mitigate initial sniping risk, while $0<p<1$ flattens the curve.

This paper describes the CBMM pool as a token rollout mechanism, but generalizing CBMM to other asset pairs is feasible. Possible extensions and enhancements include allowing third-party liquidity provision (LP) in a controlled manner and analyzing CBMM pool with nonzero initial token reserve that should be preserved by the burn mechanism. These mechanisms might require $V<0$ and are left for future study.

% =====================================================
% BIBLIOGRAPHY
% =====================================================
\newpage
\printbibliography

% =====================================================
% APPENDICES (OPTIONAL)
% =====================================================
% \newpage
% \appendix
% \section{Additional Proofs}
% \label{app:proofs}

\end{document}
