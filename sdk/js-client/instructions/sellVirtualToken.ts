/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  combineCodec,
  fixDecoderSize,
  fixEncoderSize,
  getAddressEncoder,
  getBytesDecoder,
  getBytesEncoder,
  getProgramDerivedAddress,
  getStructDecoder,
  getStructEncoder,
  getU64Decoder,
  getU64Encoder,
  transformEncoder,
  type AccountMeta,
  type AccountSignerMeta,
  type Address,
  type FixedSizeCodec,
  type FixedSizeDecoder,
  type FixedSizeEncoder,
  type Instruction,
  type InstructionWithAccounts,
  type InstructionWithData,
  type ReadonlyAccount,
  type ReadonlyUint8Array,
  type TransactionSigner,
  type WritableAccount,
  type WritableSignerAccount,
} from '@solana/kit';
import { CPMM_POC_PROGRAM_ADDRESS } from '../programs';
import {
  expectAddress,
  getAccountMetaFactory,
  type ResolvedAccount,
} from '../shared';

export const SELL_VIRTUAL_TOKEN_DISCRIMINATOR = new Uint8Array([
  9, 127, 144, 65, 96, 233, 54, 133,
]);

export function getSellVirtualTokenDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(
    SELL_VIRTUAL_TOKEN_DISCRIMINATOR
  );
}

export type SellVirtualTokenInstruction<
  TProgram extends string = typeof CPMM_POC_PROGRAM_ADDRESS,
  TAccountPayer extends string | AccountMeta<string> = string,
  TAccountPayerAta extends string | AccountMeta<string> = string,
  TAccountVirtualTokenAccount extends string | AccountMeta<string> = string,
  TAccountPool extends string | AccountMeta<string> = string,
  TAccountPoolAta extends string | AccountMeta<string> = string,
  TAccountCentralStateAta extends string | AccountMeta<string> = string,
  TAccountCentralState extends string | AccountMeta<string> = string,
  TAccountAMint extends string | AccountMeta<string> = string,
  TAccountSystemProgram extends
    | string
    | AccountMeta<string> = '11111111111111111111111111111111',
  TAccountTokenProgram extends
    | string
    | AccountMeta<string> = 'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA',
  TRemainingAccounts extends readonly AccountMeta<string>[] = [],
> = Instruction<TProgram> &
  InstructionWithData<ReadonlyUint8Array> &
  InstructionWithAccounts<
    [
      TAccountPayer extends string
        ? WritableSignerAccount<TAccountPayer> &
            AccountSignerMeta<TAccountPayer>
        : TAccountPayer,
      TAccountPayerAta extends string
        ? WritableAccount<TAccountPayerAta>
        : TAccountPayerAta,
      TAccountVirtualTokenAccount extends string
        ? WritableAccount<TAccountVirtualTokenAccount>
        : TAccountVirtualTokenAccount,
      TAccountPool extends string
        ? WritableAccount<TAccountPool>
        : TAccountPool,
      TAccountPoolAta extends string
        ? WritableAccount<TAccountPoolAta>
        : TAccountPoolAta,
      TAccountCentralStateAta extends string
        ? WritableAccount<TAccountCentralStateAta>
        : TAccountCentralStateAta,
      TAccountCentralState extends string
        ? WritableAccount<TAccountCentralState>
        : TAccountCentralState,
      TAccountAMint extends string
        ? ReadonlyAccount<TAccountAMint>
        : TAccountAMint,
      TAccountSystemProgram extends string
        ? ReadonlyAccount<TAccountSystemProgram>
        : TAccountSystemProgram,
      TAccountTokenProgram extends string
        ? ReadonlyAccount<TAccountTokenProgram>
        : TAccountTokenProgram,
      ...TRemainingAccounts,
    ]
  >;

export type SellVirtualTokenInstructionData = {
  discriminator: ReadonlyUint8Array;
  bAmount: bigint;
};

export type SellVirtualTokenInstructionDataArgs = { bAmount: number | bigint };

export function getSellVirtualTokenInstructionDataEncoder(): FixedSizeEncoder<SellVirtualTokenInstructionDataArgs> {
  return transformEncoder(
    getStructEncoder([
      ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
      ['bAmount', getU64Encoder()],
    ]),
    (value) => ({ ...value, discriminator: SELL_VIRTUAL_TOKEN_DISCRIMINATOR })
  );
}

export function getSellVirtualTokenInstructionDataDecoder(): FixedSizeDecoder<SellVirtualTokenInstructionData> {
  return getStructDecoder([
    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
    ['bAmount', getU64Decoder()],
  ]);
}

export function getSellVirtualTokenInstructionDataCodec(): FixedSizeCodec<
  SellVirtualTokenInstructionDataArgs,
  SellVirtualTokenInstructionData
> {
  return combineCodec(
    getSellVirtualTokenInstructionDataEncoder(),
    getSellVirtualTokenInstructionDataDecoder()
  );
}

export type SellVirtualTokenAsyncInput<
  TAccountPayer extends string = string,
  TAccountPayerAta extends string = string,
  TAccountVirtualTokenAccount extends string = string,
  TAccountPool extends string = string,
  TAccountPoolAta extends string = string,
  TAccountCentralStateAta extends string = string,
  TAccountCentralState extends string = string,
  TAccountAMint extends string = string,
  TAccountSystemProgram extends string = string,
  TAccountTokenProgram extends string = string,
> = {
  payer: TransactionSigner<TAccountPayer>;
  payerAta?: Address<TAccountPayerAta>;
  virtualTokenAccount?: Address<TAccountVirtualTokenAccount>;
  pool: Address<TAccountPool>;
  poolAta?: Address<TAccountPoolAta>;
  centralStateAta?: Address<TAccountCentralStateAta>;
  centralState?: Address<TAccountCentralState>;
  aMint: Address<TAccountAMint>;
  systemProgram?: Address<TAccountSystemProgram>;
  tokenProgram?: Address<TAccountTokenProgram>;
  bAmount: SellVirtualTokenInstructionDataArgs['bAmount'];
};

export async function getSellVirtualTokenInstructionAsync<
  TAccountPayer extends string,
  TAccountPayerAta extends string,
  TAccountVirtualTokenAccount extends string,
  TAccountPool extends string,
  TAccountPoolAta extends string,
  TAccountCentralStateAta extends string,
  TAccountCentralState extends string,
  TAccountAMint extends string,
  TAccountSystemProgram extends string,
  TAccountTokenProgram extends string,
  TProgramAddress extends Address = typeof CPMM_POC_PROGRAM_ADDRESS,
>(
  input: SellVirtualTokenAsyncInput<
    TAccountPayer,
    TAccountPayerAta,
    TAccountVirtualTokenAccount,
    TAccountPool,
    TAccountPoolAta,
    TAccountCentralStateAta,
    TAccountCentralState,
    TAccountAMint,
    TAccountSystemProgram,
    TAccountTokenProgram
  >,
  config?: { programAddress?: TProgramAddress }
): Promise<
  SellVirtualTokenInstruction<
    TProgramAddress,
    TAccountPayer,
    TAccountPayerAta,
    TAccountVirtualTokenAccount,
    TAccountPool,
    TAccountPoolAta,
    TAccountCentralStateAta,
    TAccountCentralState,
    TAccountAMint,
    TAccountSystemProgram,
    TAccountTokenProgram
  >
> {
  // Program address.
  const programAddress = config?.programAddress ?? CPMM_POC_PROGRAM_ADDRESS;

  // Original accounts.
  const originalAccounts = {
    payer: { value: input.payer ?? null, isWritable: true },
    payerAta: { value: input.payerAta ?? null, isWritable: true },
    virtualTokenAccount: {
      value: input.virtualTokenAccount ?? null,
      isWritable: true,
    },
    pool: { value: input.pool ?? null, isWritable: true },
    poolAta: { value: input.poolAta ?? null, isWritable: true },
    centralStateAta: { value: input.centralStateAta ?? null, isWritable: true },
    centralState: { value: input.centralState ?? null, isWritable: true },
    aMint: { value: input.aMint ?? null, isWritable: false },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
  };
  const accounts = originalAccounts as Record<
    keyof typeof originalAccounts,
    ResolvedAccount
  >;

  // Original args.
  const args = { ...input };

  // Resolve default values.
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value =
      'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA' as Address<'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'>;
  }
  if (!accounts.payerAta.value) {
    accounts.payerAta.value = await getProgramDerivedAddress({
      programAddress:
        'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL' as Address<'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL'>,
      seeds: [
        getAddressEncoder().encode(expectAddress(accounts.payer.value)),
        getAddressEncoder().encode(expectAddress(accounts.tokenProgram.value)),
        getAddressEncoder().encode(expectAddress(accounts.aMint.value)),
      ],
    });
  }
  if (!accounts.virtualTokenAccount.value) {
    accounts.virtualTokenAccount.value = await getProgramDerivedAddress({
      programAddress,
      seeds: [
        getBytesEncoder().encode(
          new Uint8Array([
            118, 105, 114, 116, 117, 97, 108, 95, 116, 111, 107, 101, 110, 95,
            97, 99, 99, 111, 117, 110, 116,
          ])
        ),
        getAddressEncoder().encode(expectAddress(accounts.pool.value)),
        getAddressEncoder().encode(expectAddress(accounts.payer.value)),
      ],
    });
  }
  if (!accounts.poolAta.value) {
    accounts.poolAta.value = await getProgramDerivedAddress({
      programAddress:
        'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL' as Address<'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL'>,
      seeds: [
        getAddressEncoder().encode(expectAddress(accounts.pool.value)),
        getAddressEncoder().encode(expectAddress(accounts.tokenProgram.value)),
        getAddressEncoder().encode(expectAddress(accounts.aMint.value)),
      ],
    });
  }
  if (!accounts.centralState.value) {
    accounts.centralState.value = await getProgramDerivedAddress({
      programAddress,
      seeds: [
        getBytesEncoder().encode(
          new Uint8Array([
            99, 101, 110, 116, 114, 97, 108, 95, 115, 116, 97, 116, 101,
          ])
        ),
      ],
    });
  }
  if (!accounts.centralStateAta.value) {
    accounts.centralStateAta.value = await getProgramDerivedAddress({
      programAddress:
        'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL' as Address<'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL'>,
      seeds: [
        getAddressEncoder().encode(expectAddress(accounts.centralState.value)),
        getAddressEncoder().encode(expectAddress(accounts.tokenProgram.value)),
        getAddressEncoder().encode(expectAddress(accounts.aMint.value)),
      ],
    });
  }
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value =
      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;
  }

  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts.payer),
      getAccountMeta(accounts.payerAta),
      getAccountMeta(accounts.virtualTokenAccount),
      getAccountMeta(accounts.pool),
      getAccountMeta(accounts.poolAta),
      getAccountMeta(accounts.centralStateAta),
      getAccountMeta(accounts.centralState),
      getAccountMeta(accounts.aMint),
      getAccountMeta(accounts.systemProgram),
      getAccountMeta(accounts.tokenProgram),
    ],
    data: getSellVirtualTokenInstructionDataEncoder().encode(
      args as SellVirtualTokenInstructionDataArgs
    ),
    programAddress,
  } as SellVirtualTokenInstruction<
    TProgramAddress,
    TAccountPayer,
    TAccountPayerAta,
    TAccountVirtualTokenAccount,
    TAccountPool,
    TAccountPoolAta,
    TAccountCentralStateAta,
    TAccountCentralState,
    TAccountAMint,
    TAccountSystemProgram,
    TAccountTokenProgram
  >);
}

export type SellVirtualTokenInput<
  TAccountPayer extends string = string,
  TAccountPayerAta extends string = string,
  TAccountVirtualTokenAccount extends string = string,
  TAccountPool extends string = string,
  TAccountPoolAta extends string = string,
  TAccountCentralStateAta extends string = string,
  TAccountCentralState extends string = string,
  TAccountAMint extends string = string,
  TAccountSystemProgram extends string = string,
  TAccountTokenProgram extends string = string,
> = {
  payer: TransactionSigner<TAccountPayer>;
  payerAta: Address<TAccountPayerAta>;
  virtualTokenAccount: Address<TAccountVirtualTokenAccount>;
  pool: Address<TAccountPool>;
  poolAta: Address<TAccountPoolAta>;
  centralStateAta: Address<TAccountCentralStateAta>;
  centralState: Address<TAccountCentralState>;
  aMint: Address<TAccountAMint>;
  systemProgram?: Address<TAccountSystemProgram>;
  tokenProgram?: Address<TAccountTokenProgram>;
  bAmount: SellVirtualTokenInstructionDataArgs['bAmount'];
};

export function getSellVirtualTokenInstruction<
  TAccountPayer extends string,
  TAccountPayerAta extends string,
  TAccountVirtualTokenAccount extends string,
  TAccountPool extends string,
  TAccountPoolAta extends string,
  TAccountCentralStateAta extends string,
  TAccountCentralState extends string,
  TAccountAMint extends string,
  TAccountSystemProgram extends string,
  TAccountTokenProgram extends string,
  TProgramAddress extends Address = typeof CPMM_POC_PROGRAM_ADDRESS,
>(
  input: SellVirtualTokenInput<
    TAccountPayer,
    TAccountPayerAta,
    TAccountVirtualTokenAccount,
    TAccountPool,
    TAccountPoolAta,
    TAccountCentralStateAta,
    TAccountCentralState,
    TAccountAMint,
    TAccountSystemProgram,
    TAccountTokenProgram
  >,
  config?: { programAddress?: TProgramAddress }
): SellVirtualTokenInstruction<
  TProgramAddress,
  TAccountPayer,
  TAccountPayerAta,
  TAccountVirtualTokenAccount,
  TAccountPool,
  TAccountPoolAta,
  TAccountCentralStateAta,
  TAccountCentralState,
  TAccountAMint,
  TAccountSystemProgram,
  TAccountTokenProgram
> {
  // Program address.
  const programAddress = config?.programAddress ?? CPMM_POC_PROGRAM_ADDRESS;

  // Original accounts.
  const originalAccounts = {
    payer: { value: input.payer ?? null, isWritable: true },
    payerAta: { value: input.payerAta ?? null, isWritable: true },
    virtualTokenAccount: {
      value: input.virtualTokenAccount ?? null,
      isWritable: true,
    },
    pool: { value: input.pool ?? null, isWritable: true },
    poolAta: { value: input.poolAta ?? null, isWritable: true },
    centralStateAta: { value: input.centralStateAta ?? null, isWritable: true },
    centralState: { value: input.centralState ?? null, isWritable: true },
    aMint: { value: input.aMint ?? null, isWritable: false },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
  };
  const accounts = originalAccounts as Record<
    keyof typeof originalAccounts,
    ResolvedAccount
  >;

  // Original args.
  const args = { ...input };

  // Resolve default values.
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value =
      'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA' as Address<'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'>;
  }
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value =
      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;
  }

  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts.payer),
      getAccountMeta(accounts.payerAta),
      getAccountMeta(accounts.virtualTokenAccount),
      getAccountMeta(accounts.pool),
      getAccountMeta(accounts.poolAta),
      getAccountMeta(accounts.centralStateAta),
      getAccountMeta(accounts.centralState),
      getAccountMeta(accounts.aMint),
      getAccountMeta(accounts.systemProgram),
      getAccountMeta(accounts.tokenProgram),
    ],
    data: getSellVirtualTokenInstructionDataEncoder().encode(
      args as SellVirtualTokenInstructionDataArgs
    ),
    programAddress,
  } as SellVirtualTokenInstruction<
    TProgramAddress,
    TAccountPayer,
    TAccountPayerAta,
    TAccountVirtualTokenAccount,
    TAccountPool,
    TAccountPoolAta,
    TAccountCentralStateAta,
    TAccountCentralState,
    TAccountAMint,
    TAccountSystemProgram,
    TAccountTokenProgram
  >);
}

export type ParsedSellVirtualTokenInstruction<
  TProgram extends string = typeof CPMM_POC_PROGRAM_ADDRESS,
  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],
> = {
  programAddress: Address<TProgram>;
  accounts: {
    payer: TAccountMetas[0];
    payerAta: TAccountMetas[1];
    virtualTokenAccount: TAccountMetas[2];
    pool: TAccountMetas[3];
    poolAta: TAccountMetas[4];
    centralStateAta: TAccountMetas[5];
    centralState: TAccountMetas[6];
    aMint: TAccountMetas[7];
    systemProgram: TAccountMetas[8];
    tokenProgram: TAccountMetas[9];
  };
  data: SellVirtualTokenInstructionData;
};

export function parseSellVirtualTokenInstruction<
  TProgram extends string,
  TAccountMetas extends readonly AccountMeta[],
>(
  instruction: Instruction<TProgram> &
    InstructionWithAccounts<TAccountMetas> &
    InstructionWithData<ReadonlyUint8Array>
): ParsedSellVirtualTokenInstruction<TProgram, TAccountMetas> {
  if (instruction.accounts.length < 10) {
    // TODO: Coded error.
    throw new Error('Not enough accounts');
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      payer: getNextAccount(),
      payerAta: getNextAccount(),
      virtualTokenAccount: getNextAccount(),
      pool: getNextAccount(),
      poolAta: getNextAccount(),
      centralStateAta: getNextAccount(),
      centralState: getNextAccount(),
      aMint: getNextAccount(),
      systemProgram: getNextAccount(),
      tokenProgram: getNextAccount(),
    },
    data: getSellVirtualTokenInstructionDataDecoder().decode(instruction.data),
  };
}
