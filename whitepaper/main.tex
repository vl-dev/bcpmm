\documentclass[11pt,a4paper]{article}

% =====================================================
% PACKAGES
% =====================================================

% Page layout
\usepackage[margin=1in]{geometry}
\usepackage{setspace}

% Typography
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{microtype}

% Math and algorithms
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{mathtools}
\usepackage{algorithm}
\usepackage{algpseudocode}

% Graphics and figures
\usepackage{graphicx}
\usepackage{float}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{tikz}
\usepackage{pgfplots}
\pgfplotsset{compat=1.18}

% Tables
\usepackage{booktabs}
\usepackage{multirow}
\usepackage{array}

% References and citations
\usepackage[hidelinks]{hyperref}
\usepackage[capitalize,noabbrev]{cleveref}
\usepackage[backend=biber,style=numeric,sorting=none]{biblatex}
\addbibresource{references.bib}

% Code listings (useful for smart contracts)
\usepackage{listings}
\usepackage{xcolor}

% Define colors for code
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

% Code listing style
\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2
}
\lstset{style=mystyle}

% Other useful packages
\usepackage{enumitem}
\usepackage{csquotes}

% =====================================================
% THEOREM ENVIRONMENTS
% =====================================================
\theoremstyle{definition}
\newtheorem{definition}{Definition}[section]
\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}{Lemma}[section]
\newtheorem{proposition}{Proposition}[section]
\newtheorem{corollary}{Corollary}[theorem]
\newtheorem{example}{Example}[section]
\newtheorem{remark}{Remark}[section]

% =====================================================
% CUSTOM COMMANDS
% =====================================================
% Add your custom commands here
% Example: \newcommand{\R}{\mathbb{R}}

% =====================================================
% DOCUMENT METADATA
% =====================================================
\title{CBMM Pool: A Constant Burn Market Maker}
\author{Your Name\\
        Your Affiliation\\
        \texttt{your.email@example.com}}
\date{\today}

% =====================================================
% DOCUMENT
% =====================================================
\begin{document}

\maketitle

\begin{abstract}
This whitepaper describes the CBMM (Constant Burn Market Maker) pool, an improved version of the standard constant product market maker (CPMM) that automates token burns and buybacks resulting in a positive impact on the token's price and more continuous demand.
\end{abstract}

\tableofcontents
\newpage

% =====================================================
% MAIN CONTENT
% =====================================================

\section{Introduction}

\begin{itemize}
\item CFMM, CPMM, CLMM, DAMM etc.
\item mention Pump.fun, Uniswap
\item virtual reserve
\item define insolvency
\item price impact of burn
\item burn structure (in instructions)
\item price impact of the automated buybacks
\end{itemize}

% Your introduction content here

\section{Background}

\begin{itemize}
\item The goal is to design a mechanism that allows us to reward off-chain behavior by creating a direct on-chain impact on the beans price by burning the beans' supply.
\item By burning the supply we are lowering liquidity, creating scarcity.
\item We need to make sure that even after burn the pool is able to withstand sale of all the tokens even if that means that some users might be selling for a price that is worse than the starting one.
\item We have two mechanisms that help us with the positive price action on-chain - burning and continuous conditional buybacks. These mechanisms are very closely intertwined and complement each other.
\item The goal is to create a mechanism that rewards off-chain actions long term and by inducing the positive price action it motivates people to on-chain actions and speculation.
\item There is no free lunch, if we burn tokens "someone" has to pay for it.
\item two possible approaches - burn of a percentage of the pool supply/ burn of the total supply percentage
\item motivation for the virtual reserve is that otherwise it would be very cheap to snipe a big portion of the reserve. The virtual reserve helps to mitigate this by effectively setting a starting price for the token. If no burning is involved, the token price in this pool can never drop under this price. However, if burning is involved, the needed virtual price drop lowers the minimal price that the token can drop to and thereby keeps the pool healthy.
\item A slow transition from a purely virtual scaling system into a progressively collateralized one.
\item THis is a token rollout mechanism, it is not designed for tokens that are already in the market.
\item Points (beans) vs tokens
\end{itemize}

\subsection{Conventional Market Making Strategies}

\begin{itemize}
\item Description of standard CPMM pool, note about CLMM pools, DAMM pools
\item Short description of bonding curves
\item Neither of these has any mechanisms for off-chain action motivation except for a manual buyback and burn. We are replacing this with an automated solution
\end{itemize}

\section{Mathematical Model}
\label{sec:math}

In this section we will define the mathematical model of the CBMM pool. We only focus on the token trading and burning mechanics, the buyback mechanics are an extension of this model and therefore will be discussed in the \ref{sec:continuous-conditional-buybacks} section.

We first define the key terms used throughout this section.

\begin{definition}
    The \textbf{Virtual Token Reserve} $V$ is the portion of the token reserve that is not backed by actual assets. 
\end{definition}

\begin{definition}
    The \textbf{Real Token Reserve} $A$ is the token reserve in the pool that is backed by actual assets.
\end{definition}

\begin{definition}
    \textbf{Insolvency} is the state of the pool where its reserves are insufficient to accommodate the sale of all outstanding beans.
\end{definition}

We assume the initial Real Token Reserve reserve is zero. CBMM is designed as a token rollout mechanism, so we do not need to account for any existing supply outside the pool. The virtual reserve sets the initial price of the token.

\subsection{Trading}

Buys and sells in CBMM follow the mechanics of the standard CPMM with a virtual reserve; we include them here for completeness. Denote the pre-trade (buy or sell) values as:

\begin{align*}
    A_0 &= A, \\
    B_0 &= B, \\
    V_0 &= V, \\
    k_0 &= k = (A+V)B
\end{align*}

During trading, the invariant $k$ and the virtual reserve $V$ do not change. The amount of beans $b$ received by the user when spending $\Delta A$ tokens (which increases the pool reserve to $A+\Delta A$) follows from
\begin{equation}
    k = (A+\Delta A+V)(B-b),
\end{equation}
which gives:

\begin{equation}
    b = B - \frac{k}{A+\Delta A+V}.
\end{equation}

Similarly, the amount of tokens $a$ received by the user when spending $\Delta B$ beans (which increases the pool reserve to $B+\Delta B$) follows from
\begin{equation}
    k = (A-a+V)(B+\Delta B),
\end{equation}
which gives:

\begin{equation}
    a = A+V - \frac{k}{B+\Delta B}.
\end{equation}

The current price of beans is:

\begin{equation}
    P = \frac{A+V}{B}.
\end{equation}

\subsection{Beans Supply Burning}

Let the initial state of the pool be:

\begin{align*}
    A_0 &= 0, \\
    B_0 &= B, \\
    V_0 &= V, \\
    k_0 &= (0+V)B = VB
\end{align*}

Assume, without loss of generality, that trading occurs before the burn, lowering the beans reserve by $x \geq 0$. The post-trade values are then:

\begin{align*}
    A_1 &= \frac{Vx}{B-x}, \\
    B_1 &= B - x, \\
    V_1 &= V, \\
    k_1 &= k_0
\end{align*}

Now, if we burn $y$ beans with $0 \leq y < B - x$, the post-burn state is:

\begin{align*}
    A_2 &= \frac{Vx}{B-x}, \\
    B_2 &= B - x - y, \\
    V_2 &\text{ to be determined}, \\
    k_2 &= (A_2+V_2)B_2
\end{align*}

To ensure the pool is not insolvent, if everyone sells their beans back to the pool, there must be sufficient tokens to satisfy the sale. The post-sale state must satisfy:

\begin{align*}
    A_3 &\geq 0, \\
    B_3 &= B - y, \\
    V_3 &= V_2, \\
    k_3 &= (A_3+V_3)B_3
\end{align*}

From $k_2 = k_3$ and $k_3 \geq V_3 B_3$, we obtain a bound on $V_2$ that ensures the pool is not insolvent:

\begin{equation}
    V_2 \leq \frac{V(B-x-y)}{B-x}.
\end{equation}

Thus, after every burn, the virtual reserve must be adjusted downward to avoid insolvency. A natural choice is to set $V_2$ to the maximum value satisfying the bound, which minimizes price impact.

\subsubsection{Price impact of the burn}

Denote the price before burn as $P_1 = \frac{A_1+V_1}{B_1}$ and the price after burn as $P_2 = \frac{A_2+V_2}{B_2}$. Substituting the values from the previous section, where $B_1 = B - x$ and $V_2 = \frac{V(B-x-y)}{B-x}$, we obtain:

\begin{align*}
    P_1 &= \frac{A_1 + V_1}{B_1} = \frac{\frac{Vx}{B-x} + V}{B-x} = \frac{VB}{(B-x)^2}, \\
    P_2 &= \frac{A_2 + V_2}{B_2} = \frac{\frac{Vx}{B-x} + \frac{V(B-x-y)}{B-x}}{B-x-y} = \frac{V(B-y)}{(B-x)(B-x-y)}.
\end{align*}

The relative price impact of the burn is then:

\begin{equation}
    \frac{P_2 - P_1}{P_1} = \frac{xy}{B(B-x-y)}.
\end{equation}

This formula shows that the relative price impact is proportional to the product $xy$ of beans bought ($x$) and beans burned ($y$), divided by $B(B-x-y)$. The impact increases with the amount of beans held outside the pool ($x$), meaning burns have greater price impact when more tokens have been purchased. If $x = 0$ (no tokens purchased), the burn has no price impact, as expected.

\subsection{Power CBMM}

Power CBMM generalizes the standard CBMM by using a power parameter in the invariant:

\begin{equation}
    k = (A+V)B^p,
\end{equation}

where $p > 0$ is a real parameter. When $p = 1$, this reduces to the standard CBMM invariant. The parameter $p$ controls the curvature of the bonding curve: $p > 1$ produces a steeper curve, while $0 < p < 1$ produces a flatter curve. This allows fine-tuning of the pool's behavior, particularly affecting initial token purchases and the distribution of tokens to early adopters.

The trading formulas for Power CBMM follow from the invariant $k = (A+V)B^p$. When spending $\Delta A$ tokens to buy beans, the amount of beans $b$ received is:

\begin{equation}
    b = B - \left(\frac{(A+V)B^p}{A+\Delta A+V}\right)^{1/p}.
\end{equation}

When spending $\Delta B$ beans to sell, the amount of tokens $a$ received is:

\begin{equation}
    a = (A+V)\left(1 - \frac{B^p}{(B+\Delta B)^p}\right).
\end{equation}

After burning $y$ beans when $x$ beans have already been purchased, the virtual reserve must be adjusted to maintain solvency. The adjusted virtual reserve $V_2$ is:

\begin{equation}
    V_2 = \frac{V \left((B-x)^p - B^p\right) (B-x-y)^p}{(B-x)^p \left((B-x-y)^p - (B-y)^p\right)},
\end{equation}

where $(B-x)^p \left((B-y)^p - (B-x-y)^p\right) \neq 0$.


\section{Implementation}

This section describes an on-chain implementation of CBMM as a Solana program. We first present the Continuous Conditional Buybacks mechanism, which partially offsets the required reduction in the virtual reserve $V$ after burns. We then outline safety controls for burn operations and note key configuration considerations. The design objective is to minimize user friction while faithfully realizing the mathematical model from \S\ref{sec:math}.

\subsection{Continuous Conditional Buybacks}

Burns require a reduction of the virtual reserve from $V_1$ to $V_2$ (with $V_2 \le V_1$). This adjustment reduces the positive impact of the burn. We implement \emph{Continuous Conditional Buybacks} (CCB) to partially offset this by redirecting a portion of trading fees into the real token reserve $A$, which bumps the price slightly back up.

Let $\Delta V := V_1 - V_2 \ge 0$ denote the required reduction in virtual reserve implied by \S\ref{sec:math}. The mechanism is:

\begin{itemize}[leftmargin=*]
  \item \textbf{Fee accumulation}: On each trade, a fixed fraction of token fees is routed to a dedicated on-chain fee vault (an associated token account controlled by the program).
  \item \textbf{Burn-time top-up}: Upon a burn event, the program deposits into $A$ an amount $\Delta A_{\text{topup}} := \min(\Delta V,\ F)$, where $F$ is the available collected fee balance. Any shortfall $L := \Delta V - \Delta A_{\text{topup}} \ge 0$ is stored in pool state as an outstanding liability.
  \item \textbf{Continuous repayment}: While $L>0$, subsequent trades continue to contribute fees that are immediately applied to reduce $L$ until it reaches zero. Any overage remains in the fee vault and is handled by the fee accumulation rule.
\end{itemize}

The choice of top-up target $V_2 - V_1$ is an arbitrary decision, other targets are possible. We use it because it naturally ``compensates'' for the virtual reserve reduction, even though this compensation is not exact as the amount in the real token reserve can be later extracted while trading. Technically, this is not a buyback, as no beans leave the pool. However, adding tokens to $A$ increases the beans' price and effectively buys back part of the burn's price impact.

\subsection{Burn Safety Mechanisms}

To bound operational risk and align burns with off-chain incentives, we introduce two optional controls: (i) per-user daily limits and (ii) an authorization gate for burns.

\subsubsection{Daily burn limits}

We introduce a lightweight on-chain meter, \texttt{UserBurnAllowance}, keyed by user. It records the number of burns over a rolling 24-hour window and the timestamp of the most recent burn. Account creation is permissionless (similarly to SPL Associated Token Accounts) so any party can create and fund an account to bootstrap a user's allowance. To avoid rent leakage, accounts associated with users inactive for $\geq 24$ hours may be closed and rent returned to the original funding wallet. If a user exceeds the configured daily limit, additional burn attempts are rejected until the window resets.

For lowest-cost deployments, equivalent functionality could be realized via State Compression (e.g., Merkle-tree-based indexing), at the cost of off-chain infrastructure dependence.

\subsubsection{Burn authority}

On every burn we require a signature from a Burn Authority. This ensures that all burns are tied to specific off-chain activities and that users have not simply automated the burn operation by calling the program directly. This mechanism is optional and can be turned off if decentralization is a priority.


\subsection{Pool Configuration Considerations}

\begin{itemize}
  \item Larger $V$ hardens the pool against early sniping by increasing the A-per-bean starting price and the A required for large initial purchases.
  \item The Power CBMM variant (parameter $p$) allows shaping the bonding curve: $p>1$ concentrates price impact earlier; $0<p<1$ spreads it more evenly.
  \item The deployment described here is single-sided: only beans (B) are minted and traded; the real reserve is entirely in tokens (A).
\end{itemize}

\section{Analysis}
\label{sec:analysis}

\begin{itemize}
\item burns themselves pump the price proportionally to the amount of beans outside the pool
\item volume itself doesn't pump the price
\item these two mechanisms complement each other and motivate users to do one or another.
\item real initial reserve is useless as it is immediately used 
\item burns result in less supply in the pool, which is good for the price, but increases volatility
\item $V$ linear scaling doesn't have any impact on burn percentage
\item burns increate the pool volatility
\end{itemize}

% Analysis and evaluation

\section{Conclusion}
\label{sec:conclusion}

\begin{itemize}
\item We are rolling this out as a closed system with beans, but the concept is applicable to any asset pair
\item Could be generalized, $V$ could go under 0 to be able to keep the pool solvent if starting token reserve is greater than zero and we want to retain it after all the beans return to the pool.
\item We do not use real tokens, but it's generalizable to any asset pair
\item People LP positioning into the pool?
\end{itemize}

% Your conclusions

% =====================================================
% BIBLIOGRAPHY
% =====================================================
\newpage
\printbibliography

% =====================================================
% APPENDICES (OPTIONAL)
% =====================================================
% \newpage
% \appendix
% \section{Additional Proofs}
% \label{app:proofs}

\end{document}
