\documentclass[11pt,a4paper]{article}

% =====================================================
% PACKAGES
% =====================================================

% Page layout
\usepackage[margin=1in]{geometry}
\usepackage{setspace}

% Typography
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{microtype}

% Math and algorithms
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{mathtools}
\usepackage{algorithm}
\usepackage{algpseudocode}

% Graphics and figures
\usepackage{graphicx}
\usepackage{float}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{tikz}
\usepackage{pgfplots}
\pgfplotsset{compat=1.18}

% Tables
\usepackage{booktabs}
\usepackage{multirow}
\usepackage{array}

% References and citations
\usepackage[hidelinks]{hyperref}
\usepackage[capitalize,noabbrev]{cleveref}
\usepackage[backend=biber,style=numeric,sorting=none]{biblatex}
\addbibresource{references.bib}

% Code listings (useful for smart contracts)
\usepackage{listings}
\usepackage{xcolor}

% Define colors for code
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

% Code listing style
\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2
}
\lstset{style=mystyle}

% Other useful packages
\usepackage{enumitem}
\usepackage{csquotes}

% =====================================================
% THEOREM ENVIRONMENTS
% =====================================================
\theoremstyle{definition}
\newtheorem{definition}{Definition}[section]
\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}{Lemma}[section]
\newtheorem{proposition}{Proposition}[section]
\newtheorem{corollary}{Corollary}[theorem]
\newtheorem{example}{Example}[section]
\newtheorem{remark}{Remark}[section]

% =====================================================
% CUSTOM COMMANDS
% =====================================================
% Add your custom commands here
% Example: \newcommand{\R}{\mathbb{R}}

% =====================================================
% DOCUMENT METADATA
% =====================================================
\title{CBMM Pool: A Constant Burn Market Maker}
\author{Your Name\\
        Your Affiliation\\
        \texttt{your.email@example.com}}
\date{\today}

% =====================================================
% DOCUMENT
% =====================================================
\begin{document}

\maketitle

\begin{abstract}
This whitepaper describes the CBMM (Constant Burn Market Maker) pool, an improved version of the standard constant product market maker (CPMM) that automates token burns and buybacks resulting in a positive impact on the token's price and more continuous demand.
\end{abstract}

\tableofcontents
\newpage

% =====================================================
% MAIN CONTENT
% =====================================================

\section{Introduction}

- CPMM, CLMM
- originally pioneered by Uniswap?
- mention Pump.fun
- virtual reserve
- define insolvency
- price impact of burn
- burn structure (in instructions)
- price impact of the automated buybacks

% Your introduction content here

\section{Background}

- The goal is to design a mechanism that allows us to reward off-chain behavior by creating a direct on-chain impact on the beans price by burning the beans' supply.
- By burning the supply we are lowering liquidity, creating scarcity.
- We need to make sure that even after burn the pool is able to withstand sale of all the tokens even if that means that some users might be selling for a price that is worse than the starting one.
- We have two mechanisms that help us with the positive price action on-chain - burning and continuous conditional buybacks. These mechanisms are very closely intertwined and complement each other.
- The goal is to create a mechanism that rewards off-chain actions long term and by inducing the positive price action it motivates people to on-chain actions and speculation.
- There is no free lunch, if we burn tokens "someone" has to pay for it.
- two possible approaches - burn of a percentage of the pool supply/ burn of the total supply percentage
- motivation for the virtual reserve is that otherwise it would be very cheap to snipe a big portion of the reserve. The virtual reserve helps to mitigate this by effectively setting a starting price for the token. If no burning is involved, the token price in this pool can never drop under this price. However, if burning is involved, the needed virtual price drop lowers the minimal price that the token can drop to and thereby keeps the pool healthy.
- A slow transition from a purely virtual scaling system into a progressively collateralized one.
- THis is a token rollout mechanism, it is not designed for tokens that are already in the market.

\subsection{Conventional Market Making Strategies}

- Description of standard CPMM pool, note about CLMM pools, DAMM pools
- Short description of bonding curves
- Neither of these has any mechanisms for off-chain action motivation except for a manual buyback and burn. We are replacing this with an automated solution

\section{Mathematical Model}
\label{sec:math}

We first define the key terms used throughout this section.

\begin{definition}
    The \textbf{Virtual Token Reserve} $V$ is the portion of the token reserve that is not backed by actual assets. 
\end{definition}

\begin{definition}
    The \textbf{Real Token Reserve} $A$ is the token reserve in the pool that is backed by actual assets.
\end{definition}

\begin{definition}
    \textbf{Insolvency} is the state of the pool where its reserves are insufficient to accommodate the sale of all outstanding beans.
\end{definition}

We assume the initial Real Token Reserve reserve is zero. CBMM is designed as a token rollout mechanism, so we do not need to account for any existing supply outside the pool. The virtual reserve sets the initial price of the token.

\subsection{Trading}

Buys and sells in CBMM follow the mechanics of the standard CPMM with a virtual reserve; we include them here for completeness. Denote the pre-trade (buy or sell) values as:

\begin{align*}
    A_0 &= A, \\
    B_0 &= B, \\
    V_0 &= V, \\
    k_0 &= k = (A+V)B
\end{align*}

During trading, the invariant $k$ and the virtual reserve $V$ do not change. The amount of beans $b$ received by the user when spending $\Delta A$ tokens (which increases the pool reserve to $A+\Delta A$) follows from
\begin{equation}
    k = (A+\Delta A+V)(B-b),
\end{equation}
which gives:

\begin{equation}
    b = B - \frac{k}{A+\Delta A+V}.
\end{equation}

Similarly, the amount of tokens $a$ received by the user when spending $\Delta B$ beans (which increases the pool reserve to $B+\Delta B$) follows from
\begin{equation}
    k = (A-a+V)(B+\Delta B),
\end{equation}
which gives:

\begin{equation}
    a = A+V - \frac{k}{B+\Delta B}.
\end{equation}

The current price of beans is:

\begin{equation}
    P = \frac{A+V}{B}.
\end{equation}

\subsection{Beans Supply Burning}

Let the initial state of the pool be:

\begin{align*}
    A_0 &= 0, \\
    B_0 &= B, \\
    V_0 &= V, \\
    k_0 &= (0+V)B = VB
\end{align*}

Assume, without loss of generality, that trading occurs before the burn, lowering the beans reserve by $x \geq 0$. The post-trade values are then:

\begin{align*}
    A_1 &= \frac{Vx}{B-x}, \\
    B_1 &= B - x, \\
    V_1 &= V, \\
    k_1 &= k_0
\end{align*}

Now, if we burn $y$ beans with $0 \leq y < B - x$, the post-burn state is:

\begin{align*}
    A_2 &= \frac{Vx}{B-x}, \\
    B_2 &= B - x - y, \\
    V_2 &\text{ to be determined}, \\
    k_2 &= (A_2+V_2)B_2
\end{align*}

To ensure the pool is not insolvent, if everyone sells their beans back to the pool, there must be sufficient tokens to satisfy the sale. The post-sale state must satisfy:

\begin{align*}
    A_3 &\geq 0, \\
    B_3 &= B - y, \\
    V_3 &= V_2, \\
    k_3 &= (A_3+V_3)B_3
\end{align*}

From $k_2 = k_3$ and $k_3 \geq V_3 B_3$, we obtain a bound on $V_2$ that ensures the pool is not insolvent:

\begin{equation}
    V_2 \leq \frac{V(B-x-y)}{B-x}.
\end{equation}

Thus, after every burn, the virtual reserve must be adjusted downward to avoid insolvency. A natural choice is to set $V_2$ to the maximum value satisfying the bound, which minimizes price impact.


\section{Implementation}
\label{sec:implementation}

- We set A = 0
% Implementation details

\section{Analysis}
\label{sec:analysis}

- burns themselves don't pump the price (by much?)
- volume itself doesn't pump the price
- these two mechanisms complement each other and motivate users to do one or another.
- real initial reserve is useless as it is immediately used 

% Analysis and evaluation

\section{Conclusion}
\label{sec:conclusion}

- We are rolling this out as a closed system with beans, but the concept is applicable to any asset pair
- Could be generalized, $V$ could go under 0 to be able to keep the pool solvent if starting token reserve is greater than zero and we want to retain it after all the beans return to the pool.

% Your conclusions

% =====================================================
% BIBLIOGRAPHY
% =====================================================
\newpage
\printbibliography

% =====================================================
% APPENDICES (OPTIONAL)
% =====================================================
% \newpage
% \appendix
% \section{Additional Proofs}
% \label{app:proofs}

\end{document}
